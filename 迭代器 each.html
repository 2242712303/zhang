<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
// forEach()
//        迭代器forEach方法接收一个函数作为参数，对数组中每个元素使用这个函数，
//        只调用这个函数，数组本身没有任何变化
//        function squery(num) {
//            document.write(num+"&nbsp;&nbsp;"+num*num+"&nbsp;&nbsp;")
//        }
//        var nums=[1,2,3,4,5,6,7,8];
//        nums.forEach(squery)
////every  迭代器方法接受返回种子为布尔值类型的函数，对数组中的每个元素使用这个函数，如果
////       对于所有的元素，该函数均返回true，则该方法返回true,否则返回false
//        function isEven(b) {
//            return b%2==0;
//        }
//        var bs=[6,1]
//        document.write(bs.every(isEven)+"<br>")
////        document.write(bs.some(isEven)+"<br>")
//// some  迭代器方法也是接受一个返回值为布尔类型 的函数，只要有一个元素使得给函数的返回值为true,该
////        方法就返回true
//
//// reduce迭代器依次相加，最后返回相加的值，也可以把数组中的元素连城一个长的字符串
////           reduceRight是从右向左
        function add(m,n) {
            return m+n
        }
        var adds=[1,2,3,4,5,6,7,8,9];
        var nihao=["ni ","hao ","zhong ","guo "]
        document.write(adds.reduce(add)+"<br>")
        document.write(nihao.reduce(add)+"<br>")
        document.write(nihao.reduceRight(add)+"<br>")
//// map()迭代器和forEach有些类似，但是map会改变数组，生成新的数组
//        function mapp(grade) {
////            return grade+8
//            return grade+"hao"
//        }
//         var grades=[1,2,3,4,5,6]
//        document.write(grades.map(mapp)+"<br>")
////        fiter迭代器和every迭代器类似，传入一个返回值为布尔类型的函数，
//// 和every方法不同的是，当数组中所有元素对应该函数返回的结果均为true时，
//// 该方法并不返回true，而是返回一个新的数组，该数组包含对应函数返回结果为true的元素
//        function fiterr(solid) {
//            return solid%2==0
//        }
//        function fit1(sod) {
//            return sod%2!=0
//        }
//        var numer=[];
//        for(var v=0;v<20;v++){
//            numer[v]=v+1
//        }
//        document.write(numer+"<br>")
//        document.write(numer.filter(fiterr)+"<br>")
//        document.write(numer.filter(fit1)+"<br>")
    </script>
</head>
<body>

</body>
</html>